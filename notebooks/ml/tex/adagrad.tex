\section{AdaGrad}

Due to the nondifferentiability of the \emph{hinge} loss, we might end up in a situation where some components of the gradient are very small and others large. So, given a learning rate, a standard gradient descent approach might end up in a situation where it decreases too quickly the small weights or too slowly the large ones.

\emph{AdaGrad} \cite{duchi2011adaptive} addresses this problem by introducing the aggregate of the squares of previously observed gradients to adjust the learning rate. This has two benefits: first, we no longer need to decide just when a gradient is large enough. Second, it scales automatically with the magnitude of the gradients. Coordinates that routinely correspond to large gradients are scaled down significantly, whereas others with small gradients receive a much more gentle treatment.

We use the variable $s_t$ to accumulate past gradient variance as follows:
	
\begin{equation} \label{eq:adagrad}
	\begin{split}
    	\begin{aligned}
        	g_t & = \partial_{{w_t}} \mathcal{L}(y_t, f(x_t, w)) \\
        	s_t & = s_{t-1} + g_t^2 \\
        	w_{t+1} & = w_t - \frac{\eta}{\sqrt{s_t + \epsilon}} \cdot g_t
    	\end{aligned}
	\end{split}
\end{equation}

where $\epsilon$ is an additive constant that ensures that we do not divide by 0. 

\begin{algorithm}[h!]
	\caption{AdaGrad Algorithm. The learning rate $\eta$, the $\alpha$ term and the maximum number of iterations are given.}
	\label{alg:adagrad}
	\begin{algorithmic}[1]
		\Require{Learning rate $\eta$ and momentum parameter $\alpha$}
		\Require{Maximum number of iteration and error threshold}
		\Procedure{Momentum Descent}{}
			\State Initialize \textbf{w} and \textbf{v}
			\State $k \gets 0$
			\While {$k < max\_iterations$ \&\& $error\_th<e$}
				\If {Nesterov Momentum}
					\State $\tilde{\textbf{W}} \gets \textbf{w} + \alpha \textbf{v}$
				\EndIf
				\State Compute gradient estimate: $\textbf{g} \gets \frac {1}{n} \nabla \sum_i\textit{L}(\tilde{\textbf{W}})$
				\State Compute velocity update: $\textbf{v} \gets \alpha \textbf{v} - \eta \textbf{g}$
				\State Apply update: $\textbf{w} \gets \textbf{w} + \textbf{v}$
			\EndWhile
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
